# Updated : 2024.07.13
# Version : 2.2.1
# GitHub  : https://github.com/Sleeper85/esphome-jk-bms-can

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

globals:
  - id: ${canbus_id}_ack_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${canbus_id}_msg_counter
    type: int
    restore_value: no
    initial_value: '0'

select:
  - platform: template
    name: ${name} ${canbus_name} BMS Name
    id: ${canbus_id}_bms_name
    options:
      - "SMARTBMS"
      - "PYLON"
      - "GOODWE"
      - "SEPLOS"
      - "SMA"
    restore_value: true
    initial_option: "PYLON"
    optimistic: true
    entity_category: config
    set_action:
      - logger.log:
          format: "Chosen option: %s"
          args: ["x.c_str()"]
  - platform: template
    name: ${name} ${canbus_name} Protocol
    id: ${canbus_id}_protocol
    options:
      - "GENERAL"
      - "PYLON 1.2"
      - "PYLON +"
      - "SMA"
      - "VICTRON"
    restore_value: true
    initial_option: "PYLON +"
    optimistic: true
    entity_category: config
    set_action:
      - logger.log:
          format: "Chosen option: %s"
          args: ["x.c_str()"]

binary_sensor:
  - platform: template
    name: "${name} ${canbus_name} Status"
    id: ${canbus_id}_status
    entity_category: diagnostic

# +--------------------------------------+
# | Start CAN Handling                   |
# +--------------------------------------+

#canbus: # 0x305 - Inverter ACK - SMA/LG/Pylon/Goodwe reply
#  - id: !extend canbus_node1

#extensions:
#  ${canbus_node_id}:

canbus: # 0x305 - Inverter ACK - SMA/LG/Pylon/Goodwe reply
  - id: !extend canbus_node1 # should be replaced by the variable ${canbus_node_id}
    on_frame:
    - can_id: 0x305
      then:
        - light.toggle:
            id: ${canbus_light_id}
        - lambda: |-
            id(${canbus_id}_ack_counter) = 0;                              // Reset ACK counter
            id(${canbus_id}_status).publish_state(true);                   // Set CANBUS Status to ON
            ESP_LOGI("main", "received can id: 0x305 ACK");

interval:
  - interval: 120s
    then:
      - lambda: id(${canbus_id}_ack_counter) = 0;                          // Reset ACK counter for test inverter ACK
          
  - interval: 100ms
    then:
      - if:
          condition:
            lambda: |-
              
              if (id(${canbus_id}_ack_counter) < ${canbus_max_no_ack}) {   // Inverter ACK ? => CANBUS ON
                
                id(${canbus_id}_ack_counter)++;                            // CANBUS ACK counter ++
                id(${canbus_id}_msg_counter)++;                            // CANBUS MSG counter ++
                return true;                                               // Condition OK
                
              }
              else if (id(${canbus_id}_status).state == false) {           // CANBUS already OFF ?
                
                return false;                                              // Nothing to do
                
              }
              else {
              
                id(${canbus_id}_status).publish_state(false);              // Set CANBUS Status to OFF
                ESP_LOGI("main", "No rx can 0x305 reply, Inverter not connected/responding...");
                return false;                                              // Condition NOK
                
              }

          then:
            - if: # 0x359 - Protection Alarms, Warning and Flags ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 1) & ((id(${canbus_id}_protocol).active_index() == 1) | (id(${canbus_id}_protocol).active_index() == 2)));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x359
                    data: !lambda |-
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};

                      // +---------------------------+
                      // | Alarm : byte 0 and 1      |
                      // +---------------------------+
                      
                      // SmartBMS alarm ?
                      if (id(${yambms_id}_alarm).state != "NoAlarm") {
                        if (id(${yambms_id}_alarm).state == "OVP") can_mesg[0] = can_mesg[0] | 0x02;   // Over Voltage Protection
                        if (id(${yambms_id}_alarm).state == "UVP") can_mesg[0] = can_mesg[0] | 0x04;   // Under Voltage Protection
                        if (id(${yambms_id}_alarm).state == "OTP") can_mesg[0] = can_mesg[0] | 0x08;   // Over Temp Protection
                        if (id(${yambms_id}_alarm).state == "UTP") can_mesg[0] = can_mesg[0] | 0x10;   // Under Temp Protection
                        if (id(${yambms_id}_alarm).state == "DOCP") can_mesg[0] = can_mesg[0] | 0x80;  // Discharge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "COCP") can_mesg[1] = can_mesg[1] | 0x80;  // Charge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "BMS") can_mesg[1] = can_mesg[1] | 0x08;   // BMS Internal Error
                        if (id(${yambms_id}_alarm).state == "UBC") can_mesg[1] = can_mesg[1] | 0x10;   // UnBalanced Cell
                      }
                      
                      // +---------------------------+
                      // | Warning : byte 2 and 3    |
                      // +---------------------------+
                      
                      // SmartBMS warning ?
                      if (id(${yambms_id}_warning).state != "NoAlarm") {
                        if (id(${yambms_id}_alarm).state == "OVP") can_mesg[2] = can_mesg[2] | 0x02;   // Over Voltage Protection
                        if (id(${yambms_id}_alarm).state == "UVP") can_mesg[2] = can_mesg[2] | 0x04;   // Under Voltage Protection
                        if (id(${yambms_id}_alarm).state == "OTP") can_mesg[2] = can_mesg[2] | 0x08;   // Over Temp Protection
                        if (id(${yambms_id}_alarm).state == "UTP") can_mesg[2] = can_mesg[2] | 0x10;   // Under Temp Protection
                        if (id(${yambms_id}_alarm).state == "DOCP") can_mesg[2] = can_mesg[2] | 0x80;  // Discharge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "COCP") can_mesg[3] = can_mesg[3] | 0x80;  // Charge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "BMS") can_mesg[3] = can_mesg[3] | 0x08;   // BMS Internal Error
                        if (id(${yambms_id}_alarm).state == "UBC") can_mesg[3] = can_mesg[3] | 0x10;   // UnBalanced Cell
                      }
                      
                      // +---------------------------+
                      // | Flags : byte 4 to 7       |
                      // +---------------------------+
                                        
                      can_mesg[4] = id(${yambms_id}_battery_module).state;      // byte4 - Module in parallel (max 8)
                      can_mesg[5] = 0x00;                                         // byte5
                      can_mesg[6] = 0x00;                                         // byte6
                      can_mesg[7] = 0x00;                                         // byte7 - DIP switches 1,3 10000100 0x84                      
                      
                      ESP_LOGI("main", "send can id: 0x359 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x35A - Protection Alarms and Warning ( SMA / Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 1) & ((id(${canbus_id}_protocol).active_index() == 3) | (id(${canbus_id}_protocol).active_index() == 4)));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x35A
                    data: !lambda |-
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                      
                      // +---------------------------+
                      // | Alarm : byte 0 to 3       |
                      // +---------------------------+
                      
                      // SmartBMS alarm ?
                      if (id(${yambms_id}_alarm).state != "NoAlarm") {
                        if (id(${yambms_id}_alarm).state == "OVP") can_mesg[0] = can_mesg[0] | 0x04;   // Over Voltage Protection
                        if (id(${yambms_id}_alarm).state == "UVP") can_mesg[0] = can_mesg[0] | 0x10;   // Under Voltage Protection
                        if (id(${yambms_id}_alarm).state == "OTP") can_mesg[0] = can_mesg[0] | 0x40;   // Over Temp Protection
                        if (id(${yambms_id}_alarm).state == "UTP") can_mesg[1] = can_mesg[1] | 0x01;   // Under Temp Protection
                        if (id(${yambms_id}_alarm).state == "DOCP") can_mesg[1] = can_mesg[1] | 0x40;  // Discharge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "COCP") can_mesg[2] = can_mesg[2] | 0x01;  // Charge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "BMS") can_mesg[2] = can_mesg[2] | 0x40;   // BMS Internal Error
                        if (id(${yambms_id}_alarm).state == "UBC") can_mesg[3] = can_mesg[3] | 0x01;   // UnBalanced Cell
                      }
                      
                      // +---------------------------+
                      // | Warning : byte 4 to 7     |
                      // +---------------------------+
                      
                      // SmartBMS warning ?
                      if (id(${yambms_id}_warning).state != "NoAlarm") {
                        if (id(${yambms_id}_alarm).state == "OVP") can_mesg[4] = can_mesg[4] | 0x04;   // Over Voltage Protection
                        if (id(${yambms_id}_alarm).state == "UVP") can_mesg[4] = can_mesg[4] | 0x10;   // Under Voltage Protection
                        if (id(${yambms_id}_alarm).state == "OTP") can_mesg[4] = can_mesg[4] | 0x40;   // Over Temp Protection
                        if (id(${yambms_id}_alarm).state == "UTP") can_mesg[5] = can_mesg[5] | 0x01;   // Under Temp Protection
                        if (id(${yambms_id}_alarm).state == "DOCP") can_mesg[5] = can_mesg[5] | 0x40;  // Discharge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "COCP") can_mesg[6] = can_mesg[6] | 0x01;  // Charge Over Current Protection
                        if (id(${yambms_id}_alarm).state == "BMS") can_mesg[6] = can_mesg[6] | 0x40;   // BMS Internal Error
                        if (id(${yambms_id}_alarm).state == "UBC") can_mesg[7] = can_mesg[7] | 0x01;   // UnBalanced Cell
                      }
                      
                      ESP_LOGI("main", "send can id: 0x35A hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x351 - BMS instruction : Charge Volts, Charge Amps, Discharge Amps, Min voltage
                condition:
                  lambda: return id(${canbus_id}_msg_counter) == 2;
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x351
                    data: !lambda |-
                      
                      // Byte [00:01] = CVL : Charge Limit Voltage    (0.1 V)
                      // Byte [02:03] = CCL : Charge Limit Current    (0.1 A)
                      // Byte [04:05] = DCL : Discharge Limit Current (0.1 A)
                      // Byte [06:07] = DVL : Discharge Limit Voltage (0.1 V)
                      
                      uint8_t can_mesg[8];
                      
                      can_mesg[0] = uint16_t(id(${yambms_id}_requested_charge_voltage).state * 10) & 0xff;
                      can_mesg[1] = uint16_t(id(${yambms_id}_requested_charge_voltage).state * 10) >> 8 & 0xff;
                      can_mesg[2] = uint16_t(id(${yambms_id}_requested_charge_current).state * 10) & 0xff;
                      can_mesg[3] = uint16_t(id(${yambms_id}_requested_charge_current).state * 10) >> 8 & 0xff;
                      can_mesg[4] = uint16_t(id(${yambms_id}_requested_discharge_current).state * 10) & 0xff;
                      can_mesg[5] = uint16_t(id(${yambms_id}_requested_discharge_current).state * 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(${yambms_id}_requested_discharge_voltage).state * 10) & 0xff;
                      can_mesg[7] = uint16_t(id(${yambms_id}_requested_discharge_voltage).state * 10) >> 8 & 0xff;
                      
                      ESP_LOGI("main", "send can id: 0x351 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x355 - Actual State of Charge (SOC), State of Health (SOH), Remaining total capacity
                condition:
                  lambda: return id(${canbus_id}_msg_counter) == 3;
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x355
                    data: !lambda |-
                      
                      // Byte [00:01] : State of Charge (SOC)    (1 %)
                      // Byte [02:03] : State of Health (SOH)    (1 %)
                      // Byte [04:05] : SOC high resolution      (0.01 %)
                      // Byte [06:07] : Remaining total capacity (1 Ah) (Sofar)

                      uint8_t can_mesg[8];

                      can_mesg[0] = uint16_t(id(${yambms_id}_battery_soc).state) & 0xff;
                      can_mesg[1] = uint16_t(id(${yambms_id}_battery_soc).state) >> 8 & 0xff;
                      can_mesg[2] = uint16_t(id(${yambms_id}_battery_soh).state) & 0xff;
                      can_mesg[3] = uint16_t(id(${yambms_id}_battery_soh).state) >> 8 & 0xff;
                      can_mesg[4] = uint16_t(id(${yambms_id}_battery_soc).state * 100) & 0xff;
                      can_mesg[5] = uint16_t(id(${yambms_id}_battery_soc).state * 100) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(${yambms_id}_capacity_remaining_ah).state * 10) & 0xff;
                      can_mesg[7] = uint16_t(id(${yambms_id}_capacity_remaining_ah).state * 10) >> 8 & 0xff;

                      ESP_LOGI("main", "send can id: 0x355 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x356 - Actual Voltage / Current / Temperature / Cycles (Deye 0x305 ACK)
                condition:
                  lambda: return id(${canbus_id}_msg_counter) == 4;
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x356
                    data: !lambda |-
                      
                      // Byte [00:01] : Actual Voltage       (0.01 V)
                      // Byte [02:03] : Actual Current       (0.1 A)
                      // Byte [04:05] : Actual Temperature   (0.1 °C)
                      // Byte [06:07] : Actual Cycles number (1 cycle) (Sofar)

                      uint8_t can_mesg[8];

                      can_mesg[0] = uint16_t(id(${yambms_id}_total_voltage).state * 100) & 0xff;
                      can_mesg[1] = uint16_t(id(${yambms_id}_total_voltage).state * 100) >> 8 & 0xff;
                      can_mesg[2] = int16_t(id(${yambms_id}_current).state * 10) & 0xff;
                      can_mesg[3] = int16_t(id(${yambms_id}_current).state * 10) >> 8 & 0xff;
                      can_mesg[4] = int16_t(((id(${yambms_id}_temperature_sensor_1).state + id(${yambms_id}_temperature_sensor_2).state) / 2) * 10) & 0xff;
                      can_mesg[5] = int16_t(((id(${yambms_id}_temperature_sensor_1).state + id(${yambms_id}_temperature_sensor_2).state) / 2) * 10) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(${yambms_id}_charging_cycles).state) & 0xff;
                      can_mesg[7] = uint16_t(id(${yambms_id}_charging_cycles).state) >> 8 & 0xff;

                      ESP_LOGI("main", "send can id: 0x356 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x35C - Request flag to Enable/Disable: Charge, Discharge ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 5) & ((id(${canbus_id}_protocol).active_index() == 1) | (id(${canbus_id}_protocol).active_index() == 2)));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x35C
                    data: !lambda |-
                      uint8_t can_mesg[2];
                      can_mesg[0] = 0x00; // Request flag
                      can_mesg[1] = 0x00; // Not used
                      
                      // +--------------------------------+
                      // | Byte0_Bit7 : Charge enable     |
                      // +--------------------------------+
                      if ((id(${yambms_id}_charging_instruction).state == "Bulk") | (id(${yambms_id}_charging_instruction).state == "Float")) can_mesg[0] = 0x80;

                      // +--------------------------------+
                      // | Byte0_Bit6 : Discharge enable  |
                      // +--------------------------------+
                      if (id(${yambms_id}_discharging_instruction).state == true) can_mesg[0] = can_mesg[0] | 0x40;

                      ESP_LOGI("main", "send can id: 0x35C hex: %x %x", can_mesg[0], can_mesg[1]);
                      return {can_mesg[0], can_mesg[1]};
                      
            - if: # 0x70  - Actual Max Cell Temp, Min Cell Temp, Max Cell V, Min Cell V ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 6) & (id(${canbus_id}_protocol).active_index() == 2));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x70
                    data: !lambda |-
                      
                      // Byte [00:01] : Max cell temperature
                      // Byte [02:03] : Min cell temperature
                      // Byte [04:05] : Max cell voltage
                      // Byte [06:07] : Min cell voltage
                      
                      int max_cell_voltage_i = id(${yambms_id}_max_cell_voltage).state * 100.0;
                      int min_cell_voltage_i = id(${yambms_id}_min_cell_voltage).state * 100.0;
                      uint8_t can_mesg[8];
                      can_mesg[0] = int16_t(max(id(${yambms_id}_temperature_sensor_1).state, id(${yambms_id}_temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[1] = int16_t(max(id(${yambms_id}_temperature_sensor_1).state, id(${yambms_id}_temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[2] = int16_t(min(id(${yambms_id}_temperature_sensor_1).state, id(${yambms_id}_temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[3] = int16_t(min(id(${yambms_id}_temperature_sensor_1).state, id(${yambms_id}_temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[4] = max_cell_voltage_i & 0xff;
                      can_mesg[5] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[6] = min_cell_voltage_i & 0xff;
                      can_mesg[7] = min_cell_voltage_i >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x70 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x371 - Actual Max Cell Temp ID, Min Cell Temp ID, Max Cell V ID, Min Cell ID ( PYLON / PYLON + )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 6) & (id(${canbus_id}_protocol).active_index() == 2));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x371
                    data: !lambda |-
                      
                      // Byte [00:01] : Max cell temperature ID
                      // Byte [02:03] : Min cell temperature ID
                      // Byte [04:05] : Max cell voltage ID
                      // Byte [06:07] : Min cell voltage ID
                      
                      uint8_t can_mesg[8];
                      
                      // Min-Max Temp. Sensor ID ?
                      if (id(${yambms_id}_temperature_sensor_1).state >= id(${yambms_id}_temperature_sensor_2).state){
                        can_mesg[0] = 0x01;
                        can_mesg[2] = 0x02;
                      }
                      else {
                        can_mesg[0] = 0x02;
                        can_mesg[2] = 0x01;
                      }
                      
                      can_mesg[1] = 0x00;
                      can_mesg[3] = 0x00;
                      can_mesg[4] = uint16_t(id(${yambms_id}_max_voltage_cell).state) & 0xff;
                      can_mesg[5] = uint16_t(id(${yambms_id}_max_voltage_cell).state) >> 8 & 0xff;
                      can_mesg[6] = uint16_t(id(${yambms_id}_min_voltage_cell).state) & 0xff;
                      can_mesg[7] = uint16_t(id(${yambms_id}_min_voltage_cell).state) >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x371 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if: # 0x372 - Battery modules information ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 7) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x372
                    data: !lambda |-
                      
                      // Byte [00:01] : Nbr. of battery modules online
                      // Byte [02:03] : Nbr. of modules blocking charge
                      // Byte [04:05] : Nbr. of modules blocking discharge
                      // Byte [06:07] : Nbr. of battery modules offline
                      
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                      can_mesg[0] = id(${yambms_id}_battery_module).state;
                      
                      ESP_LOGI("main", "send can id: 0x372 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

            - if: # 0x373 - Actual Min Cell V, Max Cell V, Min Cell Temp (Kelvin), Max Cell Temp (Kelvin) ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 8) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  canbus.send:
                    canbus_id: ${canbus_node_id}
                    can_id: 0x373
                    data: !lambda |-
                      
                      // Byte [00:01] : Min cell voltage
                      // Byte [02:03] : Max cell voltage
                      // Byte [04:05] : Min cell temperature
                      // Byte [06:07] : Max cell temperature
                      
                      int min_cell_voltage_i = id(${yambms_id}_min_cell_voltage).state * 1000.0;
                      int max_cell_voltage_i = id(${yambms_id}_max_cell_voltage).state * 1000.0;
                      int min_temp_kelvin = min(id(${yambms_id}_temperature_sensor_1).state, id(${yambms_id}_temperature_sensor_2).state) + 273.15;
                      int max_temp_kelvin = max(id(${yambms_id}_temperature_sensor_1).state, id(${yambms_id}_temperature_sensor_2).state) + 273.15;
                      
                      uint8_t can_mesg[8];
                      can_mesg[0] = min_cell_voltage_i & 0xff;
                      can_mesg[1] = min_cell_voltage_i >> 8 & 0xff;
                      can_mesg[2] = max_cell_voltage_i & 0xff;
                      can_mesg[3] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[4] = min_temp_kelvin & 0xff;
                      can_mesg[5] = min_temp_kelvin >> 8 & 0xff;
                      can_mesg[6] = max_temp_kelvin & 0xff;
                      can_mesg[7] = max_temp_kelvin >> 8 & 0xff;
                      
                      ESP_LOGI("main", "send can id: 0x373 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if: # 0x374 - Min cell voltage ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 8) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x374
                      data: !lambda |-
                        
                        int cell_id = id(${yambms_id}_min_voltage_cell).state;
                        // init 8 bytes char array values
                        char can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        // save int cell_id to 8 bytes char array
                        snprintf(can_mesg, 8, "%d", cell_id);

                        ESP_LOGI("main", "send can id: 0x374 [ASCII] Min cell voltage ID : %d", cell_id);
                        ESP_LOGI("main", "send can id: 0x374 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

            - if: # 0x375 - Max cell voltage ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 8) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x375
                      data: !lambda |-
                        
                        int cell_id = id(${yambms_id}_max_voltage_cell).state;
                        // init 8 bytes char array values
                        char can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        // save int cell_id to 8 bytes char array
                        snprintf(can_mesg, 8, "%d", cell_id);

                        ESP_LOGI("main", "send can id: 0x375 [ASCII] Max cell voltage ID : %d", cell_id);
                        ESP_LOGI("main", "send can id: 0x375 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

            - if: # 0x376 - Min cell temperature ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 8) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x376
                      data: !lambda |-
                        
                        // Min Temp. Sensor ID ?
                        if (id(${yambms_id}_temperature_sensor_1).state >= id(${yambms_id}_temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x376 [ASCII] Min Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if: # 0x377 - Max cell temperature ID [ASCII] ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 8) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x377
                      data: !lambda |-
                        
                        // Max Temp. Sensor ID ?
                        if (id(${yambms_id}_temperature_sensor_1).state >= id(${yambms_id}_temperature_sensor_2).state){
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 1");
                          return {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }
                        else {
                          ESP_LOGI("main", "send can id: 0x377 [ASCII] Max Temp. Sensor ID : 2");
                          return {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
                        }

            - if: # 0x379 - Battery Installed Capacity Ah ( PYLON + / Victron, Sol-Ark, Luxpower )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 9) & ((id(${canbus_id}_protocol).active_index() == 2) | (id(${canbus_id}_protocol).active_index() == 4)));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x379
                      data: !lambda |-
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[0] = uint16_t(id(${yambms_id}_battery_capacity).state) & 0xff;
                        can_mesg[1] = uint16_t(id(${yambms_id}_battery_capacity).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x379 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if: # 0x382 - Product identification [ASCII] ( Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 10) & (id(${canbus_id}_protocol).active_index() == 4));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x382
                      data: !lambda |-
                        ESP_LOGI("main", "send can id: 0x382 [ASCII] Product : SMARTBMS");
                        return {0x53, 0x4D, 0x41, 0x52, 0x54, 0x42, 0x4D, 0x53}; // SMARTBMS

            - if: # 0x35F - Battery information ( SMA, Victron )
                condition:
                  lambda: return ((id(${canbus_id}_msg_counter) == 11) & ((id(${canbus_id}_protocol).active_index() == 3) | (id(${canbus_id}_protocol).active_index() == 4)));
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x35F
                      data: !lambda |-
                        
                        //                SMA                 Victron
                        // Byte [00:01] : Bat-Type            Product ID
                        // Byte [02:03] : BMS Version         Firmware version (2.2 => HEX [02:02])
                        // Byte [04:05] : Bat-Capacity        Available Capacity Ah
                        // Byte [06:07] : Manufacturer ID     Hardware version
                        
                        uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                        can_mesg[2] = 0x02;
                        can_mesg[3] = 0x02;
                        can_mesg[4] = uint16_t(id(${yambms_id}_battery_capacity).state) & 0xff;
                        can_mesg[5] = uint16_t(id(${yambms_id}_battery_capacity).state) >> 8 & 0xff;
                        
                        ESP_LOGI("main", "send can id: 0x35F hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if: # 0x35E - Manufacturer name
                condition:
                  lambda: return id(${canbus_id}_msg_counter) == 12;
                then:
                  - canbus.send:
                      canbus_id: ${canbus_node_id}
                      can_id: 0x35E
                      data: !lambda |-
                        
                        if (id(${canbus_id}_bms_name).active_index() == 0){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : SMARTBMS");
                           return {0x53, 0x4D, 0x41, 0x52, 0x54, 0x42, 0x4D, 0x53}; // SMARTBMS
                        }
                        if (id(${canbus_id}_bms_name).active_index() == 1){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON ( recognized by Deye, display PYLON name and SOH )
                        }
                        else if (id(${canbus_id}_bms_name).active_index() == 2){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : GOODWE");
                           return {0x47, 0x4F, 0x4F, 0x44, 0x57, 0x45, 0x20, 0x20}; // GOODWE
                        }
                        else if (id(${canbus_id}_bms_name).active_index() == 3){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : SHEnergy");
                           return {0x53, 0x48, 0x45, 0x6E, 0x65, 0x72, 0x67, 0x79}; // SHEnergy (SEPLOS)
                        }
                        else if (id(${canbus_id}_bms_name).active_index() == 4){
                           ESP_LOGI("main", "send can id: 0x35E ASCII : SMA");
                           return {0x53, 0x4D, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20}; // SMA
                        }
                        else {
                           ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                           return {0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20}; // PYLON
                        }

                    # Reset counter
                  - lambda: id(${canbus_id}_msg_counter) = 0;
