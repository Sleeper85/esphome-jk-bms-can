substitutions:
  auto_current_name: 'Smart BMS'
  # +--------------------------------------+
  # | Use the settings below with caution  |
  # +--------------------------------------+
  # Auto charge current control will automatically reduce the charging current as a cell reaches the BMS "cell_voltage_overvoltage_recovery".
  # If unsure, leave the below settings as default, this will ensure charge current will taper correctly.
  # Factor to control the end of the charge current curve. A setting below 2 will extend the curve, above 2 will shorten the curve. 
  charge_a_factor_curve_end: "2.0"
  # Factor to adjust the shape of the charge current curve.
  # A setting below 1 will reduce current at a slow rate after the float voltage is reached, then increase as a cell reaches the BMS "cell_voltage_overvoltage_recovery".
  # A factor above 1 will reduce current at a fast rate after the float voltage is reached, then slow as a cell reaches the BMS "cell_voltage_overvoltage_recovery".
  charge_a_factor_curve_shape: "1.8"
  # Auto discharge current control will automatically reduce the charging current as a cell reaches the BMS "cell_voltage_undervoltage_recovery".
  # If unsure, leave the below settings as default, this will ensure discharge current will taper correctly.
  # Factor to control the end of the discharge current curve. A setting below 2 will extend the curve, above 2 will shorten the curve. 
  discharge_a_factor_curve_end: "2.0"
  # Factor to adjust the shape of the charge current curve.
  # A setting below 1 will reduce current at a slow rate after the float voltage is reached, then increase as a cell reaches the BMS "cell_voltage_undervoltage_recovery".
  # A factor above 1 will reduce current at a fast rate after the float voltage is reached, then slow as a cell reaches the BMS "cell_voltage_undervoltage_recovery".
  discharge_a_factor_curve_shape: "1.8"
  # Discharge knee voltage, the point at which a cell will reduce in voltage more rapidly. For LiFePO4 cells, this is generally considered to be 3.1v.
  discharge_knee_v: "3.1"

esphome:
  on_boot:
    then:
      - switch.turn_on: can_switch_auto_charge_current
      - switch.turn_on: can_switch_auto_discharge_current

switch:
  - platform: template
    name: ${auto_current_name} Automatic Charge Current
    id: can_switch_auto_charge_current
    optimistic: true
    entity_category: config
  - platform: template
    name: ${auto_current_name} Automatic Discharge Current
    id: can_switch_auto_discharge_current
    optimistic: true
    entity_category: config

sensor:
  # +--------------------------------------+
  # | Auto Charge Current Control          |
  # +--------------------------------------+
  # First, an initial charge current is calculated based upon the maximum cell voltage but only if the Auto Charge Current switch is enabled.
  - platform: copy
    source_id: max_cell_voltage
    name: ${auto_current_name} Initial Charge Current
    id: auto_ccl_initial
    unit_of_measurement: A
    device_class: current
    internal: true  
    filters:
    - lambda: !lambda |-
              // Variables
              double cell_float_v = (id(float_voltage).state / id(cell_count).state);

              // Enable Auto CCL function
              if (id(can_switch_auto_charge_current).state) id(auto_ccl_function) = true;
              else id(auto_ccl_function) = false;

              // Auto Charge Current function
              if (id(max_cell_voltage).state > id(cell_ovpr).state) return 0.0;
              else return max(0.0,(- pow(${charge_a_factor_curve_end}, pow( max(0.0, ((x - cell_float_v) / (id(cell_ovpr).state - cell_float_v))),${charge_a_factor_curve_shape}))+2) * id(charging_current).state);
  # Second, an exponential moving average is calculated. This will be used to smooth the transition between different initial charge current values.
  - platform: copy
    source_id: auto_ccl_initial
    name: ${auto_current_name} Moving Average Charge Current
    id:  auto_ccl_moving_average
    unit_of_measurement: A
    device_class: current
    internal: true  
    filters:    
    - exponential_moving_average:
        alpha: 0.15
        send_every: 1
        send_first_at: 1
  # Third, if the instantaneous initial charge current value is lower than the moving average, use that, otherwise use the moving average.
  # This means that cell voltage spikes will be reacted to quickly, but reduced cell voltages will not, preventing oscillation of requested current.
  - platform: copy
    source_id: auto_ccl_initial
    name: ${auto_current_name} Auto Charge Current
    id: auto_ccl
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    internal: false
    filters:
    - lambda: return (round(min(id(auto_ccl_moving_average).state, x) * 10) / 10);
  # +--------------------------------------+
  # | Auto Discharge Current Control       |
  # +--------------------------------------+
  # First, an initial discharge current is calculated based upon the minimum cell voltage but only if the Auto Discharge Current switch is enabled.
  - platform: copy
    source_id: min_cell_voltage
    name: ${auto_current_name} Initial Discharge Current
    id: auto_dcl_initial
    unit_of_measurement: A
    device_class: current
    internal: true  
    filters:
    - lambda: !lambda |-
              // Enable Auto DCL function
              if (id(can_switch_auto_discharge_current).state) id(auto_dcl_function) = true;
              else id(auto_dcl_function) = false;

              // Auto Discharge Current function
              if (id(min_cell_voltage).state < id(cell_uvpr).state) return 0.0;
              else return max(0.0,(- pow(${discharge_a_factor_curve_end}, pow( max(0.0, ((x - ${discharge_knee_v}) / (id(cell_uvpr).state - ${discharge_knee_v}))),${discharge_a_factor_curve_shape}))+2) * id(discharging_current).state);
  # Second, an exponential moving average is calculated. This will be used to smooth the transition between different initial discharge current values.
  - platform: copy
    source_id: auto_dcl_initial
    name: ${auto_current_name} Moving Average Discharge Current
    id:  auto_dcl_moving_average
    unit_of_measurement: A
    device_class: current
    internal: true  
    filters:    
    - exponential_moving_average:
        alpha: 0.15
        send_every: 1
        send_first_at: 1
  # Third, if the instantaneous initial discharge current value is lower than the moving average, use that, otherwise use the moving average.
  # This means that cell voltage drops will be reacted to quickly, but increased cell voltages will not, preventing oscillation of requested current.
  - platform: copy
    source_id: auto_dcl_initial
    name: ${auto_current_name} Auto Discharge Current
    id: auto_dcl
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1                         
    internal: false
    filters:
    - lambda: return (round(min(id(auto_dcl_moving_average).state, x) * 10) / 10);