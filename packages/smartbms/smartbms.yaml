# Updated : 2024.05.20
# Version : 1.2
# GitHub  : https://github.com/Sleeper85/esphome-jk-bms-can

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

# +--------------------------------------+
# | Packages                             |
# +--------------------------------------+
packages:
  smartbms_combine: !include smartbms_combine.yaml
  # If not necessary, the following packages can be commented out
  smartbms_auto_cvl: !include smartbms_auto_cvl.yaml
  smartbms_auto_ccl: !include smartbms_auto_ccl.yaml
  smartbms_auto_dcl: !include smartbms_auto_dcl.yaml

substitutions:
  # End of charge (EOC) will be triggered if current and max cell voltage meet cut-off thresholds, plus the cycle count exceeds the below threshold.
  # As default, this cycle count is set to 60 which is approximately 60 seconds. This will reduce the liklihood of premature EOC.
  smartbms_eoc_cycle_threshold: "60"
  # +----------------------------------------------------------------+
  # Information from the EVE LF280K v2 cell datasheet
  # LFP Recommended Operating Temperature Range : 10~45°C
  # Number of cycles at 25°C : 6000
  # Number of cycles at 45°C : 2500
  # 60°C  : Never charging or discharging
  # 0°C   : Never charging
  # -30°C : Never discharging
  # +----------------------------------------------------------------+
  # Over Temp Protection, Temp > OTP = Stop Charging and Discharging
  smartbms_otp: "45.0"
  # Under Temp Protection, Temp < UTP = Stop Charging
  smartbms_utp: "1.0"

globals:
  - id: ${smartbms_id}_charge_status
    type: std::string
    restore_value: no
    initial_value: '"Wait"'
  - id: ${smartbms_id}_auto_cvl
    type: float
    restore_value: no
    initial_value: '-1.0'
  - id: ${smartbms_id}_auto_ccl
    type: float
    restore_value: no
    initial_value: '-1.0'
  - id: ${smartbms_id}_auto_dcl
    type: float
    restore_value: no
    initial_value: '-1.0'
  - id: ${smartbms_id}_eoc
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${smartbms_id}_eoc_timestamp
    type: time_t
    restore_value: true
    initial_value: ''

switch:
  - platform: template
    name: "${name} ${smartbms_name} Charge enabled"
    id: ${smartbms_id}_switch_charging
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
  - platform: template
    name: "${name} ${smartbms_name} Discharge enabled"
    id: ${smartbms_id}_switch_discharging
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
  - platform: template
    name: "${name} ${smartbms_name} Float charge enabled"
    id: ${smartbms_id}_switch_float
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
  - platform: template
    name: "${name} ${smartbms_name} Force Bulk (top bal)"
    id: ${smartbms_id}_switch_force_bulk
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

number:
  # +--------------------------------------+
  # | Slider / Box                         |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${smartbms_name} Bulk voltage"
    id: "${smartbms_id}_bulk_voltage"
    step: 0.1
    min_value: 54.0
    max_value: 58.4
    restore_value: true
    mode: "${smartbms_input_number_mode}"
    initial_value: "${smartbms_bulk_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${smartbms_name} Float voltage"
    id: "${smartbms_id}_float_voltage"
    step: 0.1
    min_value: 52.8
    max_value: 58.4
    restore_value: true
    mode: "${smartbms_input_number_mode}"
    initial_value: "${smartbms_float_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${smartbms_name} Rebulk V."
    id: "${smartbms_id}_rebulk_voltage"
    step: 0.1
    min_value: 51.2
    max_value: 53.6
    restore_value: true
    mode: "${smartbms_input_number_mode}"
    initial_value: "${smartbms_rebulk_v}"
    unit_of_measurement: V
    icon: mdi:sine-wave
    optimistic: true
    entity_category: config

sensor:
  # +--------------------------------------+
  # | Last Complete Charge                 |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${smartbms_name} Last Complete Charge"
    device_class: timestamp
    id: ${smartbms_id}_eoc_timestamp_template
    lambda: return id(${smartbms_id}_eoc_timestamp);
    on_value:
      then:
        - text_sensor.template.publish:
            id: ${smartbms_id}_eoc_timestamp_human
            state: !lambda |-
                   char str[19];
                   strftime(str, sizeof(str), " %H:%M %d %b %Y", localtime(&id(${smartbms_id}_eoc_timestamp)));
                   return  {str};
    entity_category: diagnostic
  # +--------------------------------------+
  # |  Requested Charge Voltage  (CVL)     |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Requested Charge Voltage
    id: ${smartbms_id}_requested_charge_voltage
    unit_of_measurement: V
    device_class: voltage
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1
    lambda: |-
      // Bulk
      if (id(${smartbms_id}_charging_instruction).state == "Bulk"){
        if(id(${smartbms_id}_auto_cvl) == -1.0) return (id(${smartbms_id}_bulk_voltage).state + ${smartbms_inverter_offset_v}); // Auto CVL not used
        else return (id(${smartbms_id}_auto_cvl) + ${smartbms_inverter_offset_v});
      }
      // Float
      else if (id(${smartbms_id}_charging_instruction).state == "Float") return (id(${smartbms_id}_float_voltage).state + ${smartbms_inverter_offset_v});
      // Stop Charging
      else return id(${smartbms_id}_rebulk_voltage).state;
  # +--------------------------------------+
  # |  Requested Charge Current  (CCL)     |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Requested Charge Current
    id: ${smartbms_id}_requested_charge_current
    unit_of_measurement: A
    device_class: current
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1
    lambda: |-
      // Charging Allowed
      if ((id(${smartbms_id}_charging_instruction).state == "Bulk") | (id(${smartbms_id}_charging_instruction).state == "Float")){
        if(id(${smartbms_id}_auto_ccl) == -1.0) return id(${smartbms_id}_max_charge_current).state; // Auto CCL not used
        else return id(${smartbms_id}_auto_ccl);
      }
      // Charging Not Allowed
      else return 0;
  # +--------------------------------------+
  # |  Requested Discharge Voltage  (DVL)  |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Requested Discharge Voltage
    id: ${smartbms_id}_requested_discharge_voltage
    unit_of_measurement: V
    device_class: voltage
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1
    lambda: return (id(${smartbms_id}_cell_uvpr).state * id(${smartbms_id}_cell_count).state);
  # +--------------------------------------+
  # |  Requested Discharge Current  (DCL)  |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Requested Discharge Current
    id: ${smartbms_id}_requested_discharge_current
    unit_of_measurement: A
    device_class: current
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1
    lambda: |-
      // Discharging Allowed
      if (id(${smartbms_id}_discharging_instruction).state == true){
        if(id(${smartbms_id}_auto_dcl) == -1.0) return id(${smartbms_id}_max_discharge_current).state; // Auto DCL not used
        else return id(${smartbms_id}_auto_dcl);
      }
      // Stop Discharging
      else return 0;
  # +--------------------------------------+
  # | Battery module                       |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Battery module
    id: ${smartbms_id}_battery_module
    device_class: battery
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return id(${smartbms_id}_bms_counter);

      # Converting total battery Ah into number of PYLON modules
      #int batt_capacity = id(${smartbms_id}_battery_capacity).state;
      #int batt_module;
      #if (batt_capacity == 0) batt_module = 0;
      #else if (batt_capacity <= 100) batt_module = 1;
      #else if (batt_capacity <= 200) batt_module = 2;
      #else if (batt_capacity <= 300) batt_module = 3;
      #else if (batt_capacity <= 400) batt_module = 4;
      #else if (batt_capacity <= 500) batt_module = 5;
      #else if (batt_capacity <= 600) batt_module = 6;
      #else if (batt_capacity <= 700) batt_module = 7;
      #else batt_module = 8;
      #return batt_module;

  # +--------------------------------------+
  # | Battery State of Charge (SOC)        |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Battery SOC
    id: ${smartbms_id}_battery_soc
    unit_of_measurement: "%"
    device_class: battery
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: |-
      float soc = id(${smartbms_id}_state_of_charge).state;
      float min_cell_v = id(${smartbms_id}_min_cell_voltage).state;
      float cell_uvpr = id(${smartbms_id}_cell_uvpr).state;
      if (min_cell_v <= cell_uvpr) return 0;                       // Real 0% Sending 0%
      else if (soc < 1) return 2;                                  // False 0% sending 2%
      else if (soc < 99) return soc;                               // SOC < 99% => Sending BMS SOC
      else if (id(${smartbms_id}_eoc) == true) return 100;         // End Of Charge => Sending 100%
      else return 98;                                              // Otherwise => Sending 98%
  # +--------------------------------------+
  # | Battery State of Health (SOH)        |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Battery SOH
    id: ${smartbms_id}_battery_soh
    unit_of_measurement: "%"
    device_class: battery
    update_interval: ${smartbms_update_interval}
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return round(((id(${smartbms_id}_charging_cycles).state/${smartbms_max_cycles})-1)*-100);

text_sensor:
  # +--------------------------------------+
  # | Last Complete Charge                 |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${smartbms_name} Last Complete Charge Human Readable
    id: ${smartbms_id}_eoc_timestamp_human
    icon: mdi:clock-start
    entity_category: diagnostic
  # +--------------------------------------+
  # | ****** Cut-off Charging Logic ****** |
  # | ********* Charging  Status ********* |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${smartbms_name} Charging Status"
    id: ${smartbms_id}_charging_status
    update_interval: ${smartbms_update_interval}
    lambda: |-
      // +-----------------------------------------------+
      // | Cut-off Charging Logic                        |
      // +-----------------------------------------------+
      
      // Warning : information from JK BMS is not available immediately after boot
      
      // Smart BMS Alarm ?
      if (id(${smartbms_id}_alarm).state != "NoAlarm") id(${smartbms_id}_charge_status) = "Alarm";
      // Smart BMS Alarm ended ?
      else if ((id(${smartbms_id}_charge_status) == "Alarm") & (id(${smartbms_id}_alarm).state == "NoAlarm")) {
        if (id(${smartbms_id}_eoc) == true) id(${smartbms_id}_charge_status) = "EOC";
        else id(${smartbms_id}_charge_status) = "Wait";
      }
      // Float
      else if ((id(${smartbms_id}_charge_status) == "EOC") & (id(${smartbms_id}_switch_float).state)) id(${smartbms_id}_charge_status) = "Float";
      // No Float => EOC
      else if ((id(${smartbms_id}_charge_status) == "Float") & (!id(${smartbms_id}_switch_float).state)) id(${smartbms_id}_charge_status) = "EOC";
      // No Force Bulk => Wait
      else if ((id(${smartbms_id}_charge_status) == "Force Bulk") & (!id(${smartbms_id}_switch_force_bulk).state)) id(${smartbms_id}_charge_status) = "Wait";
      
      // +-----------------------------------------------+
      // | Charge ON : BMS and CAN charging switch is ON |
      // +-----------------------------------------------+
      else if ((id(${smartbms_id}_bms_switch_charging).state) & (id(${smartbms_id}_switch_charging).state)) {
      
        // Variables
        float cell_bulk_v = (id(${smartbms_id}_bulk_voltage).state / id(${smartbms_id}_cell_count).state);
        float cell_rebulk_v = (id(${smartbms_id}_rebulk_voltage).state / id(${smartbms_id}_cell_count).state);
        float cell_absorption_offset_v = (${smartbms_absorption_offset_v} / id(${smartbms_id}_cell_count).state);
        static int eoc_counter = 0;
        
        // Force Bulk Logic
        if (id(${smartbms_id}_switch_force_bulk).state) {
          // Stop Force Bulk when cells equalizing (charging ends when cells are equalized)
          if (id(${smartbms_id}_equalizing).state) {
            id(${smartbms_id}_charge_status) = "Balancing";
            id(${smartbms_id}_switch_force_bulk).turn_off();
          }
          // Force Bulk
          else id(${smartbms_id}_charge_status) = "Force Bulk";
        }
        
        // Rebulk Logic (eg: Max Cell V. <= 3.3V)
        else if (id(${smartbms_id}_max_cell_voltage).state <= cell_rebulk_v) id(${smartbms_id}_charge_status) = "Bulk";
        
        // Charging Logic
        else if ((id(${smartbms_id}_charge_status) == "Wait") | (id(${smartbms_id}_charge_status) == "Bulk") | (id(${smartbms_id}_charge_status) == "Force Bulk") | (id(${smartbms_id}_charge_status) == "Balancing") | (id(${smartbms_id}_charge_status) == "Absorption")) {
        
          // Charging
          if (id(${smartbms_id}_current).state >= 0) {
            
            float cv_min = ${smartbms_cutoff_cvmin};
            float cv_max = ${smartbms_cutoff_cvmax};
            float cutoff_current = (id(${smartbms_id}_battery_capacity).state * 0.05 * (cell_bulk_v - cv_min) / (cv_max - cv_min));
            float cutoff_voltage = (cv_min + (cv_max - cv_min)/(0.05 + cell_absorption_offset_v) * (id(${smartbms_id}_current).state / id(${smartbms_id}_battery_capacity).state));
            
            ESP_LOGI("main", "Cut-Off Current : %f", cutoff_current);
            ESP_LOGI("main", "Cut-Off Voltage : %f", cutoff_voltage);
          
            // Stop Charging
            if ((id(${smartbms_id}_current).state <= cutoff_current) & (id(${smartbms_id}_max_cell_voltage).state >= cutoff_voltage)) {
            
              // End Of Charge
              if (!id(${smartbms_id}_equalizing).state) {
                eoc_counter += 1;
                ESP_LOGI("main", "EOC Cycle Count : %i", eoc_counter);
                if (eoc_counter > ${smartbms_eoc_cycle_threshold}) {
                  eoc_counter = 0;
                  id(${smartbms_id}_charge_status) = "EOC";
                }
              }
            
            }
            // Start Charging
            else {
              eoc_counter = 0;
              // Balancing : the BMS is equalizing the cells
              if (id(${smartbms_id}_equalizing).state) id(${smartbms_id}_charge_status) = "Balancing";
              // Absorption : Max Cell V. >= Cell Absorption V.
              else if (id(${smartbms_id}_max_cell_voltage).state >= (cell_bulk_v - cell_absorption_offset_v)) id(${smartbms_id}_charge_status) = "Absorption";
              // Bulk
              else id(${smartbms_id}_charge_status) = "Bulk";
          
            }
          }
          // Discharging (!= "EOC" | != "Float")
          else if (id(${smartbms_id}_max_cell_voltage).state < (cell_bulk_v - cell_absorption_offset_v)) id(${smartbms_id}_charge_status) = "Bulk";
        }
      }
      // Charge OFF
      else id(${smartbms_id}_charge_status) = "Wait";
      
      ESP_LOGI("main", "Charge Status : %s", id(${smartbms_id}_charge_status).c_str());
      return id(${smartbms_id}_charge_status);

  # +--------------------------------------+
  # | Charging Instruction                 |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${smartbms_name} Charging Instruction"
    id: ${smartbms_id}_charging_instruction
    update_interval: ${smartbms_update_interval}
    lambda: |-
      // Alarm > Stop Charging
      if ((id(${smartbms_id}_alarm).state == "OVP") | (id(${smartbms_id}_alarm).state == "UTP") | (id(${smartbms_id}_alarm).state == "COCP") | (id(${smartbms_id}_alarm).state == "OTP") | (id(${smartbms_id}_alarm).state == "BMS")){
        return {"Stop"};
      }
      // Bulk Charge
      else if ((id(${smartbms_id}_charge_status) == "Bulk") | (id(${smartbms_id}_charge_status) == "Force Bulk") | (id(${smartbms_id}_charge_status) == "Balancing") | (id(${smartbms_id}_charge_status) == "Absorption")) {
        id(${smartbms_id}_eoc) = false;                                        // SOC 100% can't be sent
        return {"Bulk"};
      }
      // Float Charge
      else if (id(${smartbms_id}_charge_status) == "Float") {
        return {"Float"};
      }
      // End Of Charge (EOC) > Stop Charging
      else if (id(${smartbms_id}_charge_status) == "EOC") {
        id(${smartbms_id}_eoc) = true;                                         // SOC 100% can be sent
        id(${smartbms_id}_eoc_timestamp) = id(my_time).utcnow().timestamp;     // Store charge completion timestamp
        return {"Stop"};
      }
      // Wait
      else return {"Stop"};
  # +--------------------------------------+
  # | Smart BMS Alarm                      |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${smartbms_name} Alarm"
    id: ${smartbms_id}_alarm
    update_interval: ${smartbms_update_interval}
    entity_category: diagnostic
    lambda: |-
      // +---------------------------+
      // | Smart BMS errors bitmask  |
      // +---------------------------+
      
      // 0x8B 0x00 0x00: Battery warning message              0000 0000 0000 0000
      //
      // Bit 0    Low capacity                                1 (alarm), 0 (normal)    warning
      // Bit 1    Power tube overtemperature                  1 (alarm), 0 (normal)    alarm
      // Bit 2    Charging overvoltage                        1 (alarm), 0 (normal)    alarm
      // Bit 3    Discharging undervoltage                    1 (alarm), 0 (normal)    alarm
      // Bit 4    Battery over temperature                    1 (alarm), 0 (normal)    alarm
      // Bit 5    Charging overcurrent                        1 (alarm), 0 (normal)    alarm
      // Bit 6    Discharging overcurrent                     1 (alarm), 0 (normal)    alarm
      // Bit 7    Cell pressure difference                    1 (alarm), 0 (normal)    alarm
      // Bit 8    Overtemperature alarm in the battery box    1 (alarm), 0 (normal)    alarm
      // Bit 9    Battery low temperature                     1 (alarm), 0 (normal)    alarm
      // Bit 10   Cell overvoltage                            1 (alarm), 0 (normal)    alarm
      // Bit 11   Cell undervoltage                           1 (alarm), 0 (normal)    alarm
      // Bit 12   309_A protection                            1 (alarm), 0 (normal)    alarm
      // Bit 13   309_A protection                            1 (alarm), 0 (normal)    alarm
      // Bit 14   Reserved
      // Bit 15   Reserved
      //
      // Examples:
      // 0x0001 = 00000000 00000001: Low capacity alarm
      // 0x0002 = 00000000 00000010: MOS tube over-temperature alarm
      // 0x0003 = 00000000 00000011: Low capacity alarm AND power tube over-temperature alarm

      // Preventive Alarm ? (React before a BMS alarm)
      // Over Temp Protection
      if (max(id(${smartbms_id}_temperature_sensor_1).state, id(${smartbms_id}_temperature_sensor_2).state) > ${smartbms_otp}) {
         return {"OTP"};
      }
      // Under Temp Protection
      else if (min(id(${smartbms_id}_temperature_sensor_1).state, id(${smartbms_id}_temperature_sensor_2).state) < ${smartbms_utp}) {
         return {"UTP"};
      }
      // Error Bitmask ?
      else if (id(${smartbms_id}_errors_bitmask).state > 1) {
         uint16_t errors_bitmask = id(${smartbms_id}_errors_bitmask).state;

         if ((errors_bitmask & 0x04) | (errors_bitmask & 0x80) | (errors_bitmask & 0x400)) {           // Hight.Voltage.Alarm - bit 2,7,10
            return {"OVP"};
         }
         if ((errors_bitmask & 0x08) | (errors_bitmask & 0x800)) {                                     // Low.Voltage.Alarm - bit 3,11
            return {"UVP"};
         }
         if ((errors_bitmask & 0x02) | (errors_bitmask & 0x10) | (errors_bitmask & 0x100)) {           // Hight.Temp.Alarm - bit 1,4,8
            return {"OTP"};
         }
         if ((errors_bitmask & 0x200)) {                                                               // Low.Temp.Alarm - bit 9
            return {"UTP"};
         }
         if ((errors_bitmask & 0x40)) {                                                                // Discharge.Over.Current - bit 6
            return {"DOCP"};
         }
         if ((errors_bitmask & 0x20)) {                                                                // Charge.Over.Current - bit 5
            return {"COCP"};
         }
         if ((errors_bitmask & 0x1000) | (errors_bitmask & 0x2000)) {                                  // BMS.Internal.Error - bit 12,13
            return {"BMS"};
         }
         if ((errors_bitmask & 0x80)) {                                                                // Unbalanced.Cell - bit 7
            return {"UBC"};
         }
         else return {"NoAlarm"};
      }
      // No Alarm
      else return {"NoAlarm"};

binary_sensor:
  # +--------------------------------------+
  # | Discharging Instruction              |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${smartbms_name} Discharging Instruction"
    id: ${smartbms_id}_discharging_instruction
    lambda: |-
      // Alarm > Stop Discharging
      if ((id(${smartbms_id}_alarm).state == "UVP") | (id(${smartbms_id}_alarm).state == "DOCP") | (id(${smartbms_id}_alarm).state == "OTP") | (id(${smartbms_id}_alarm).state == "BMS")) return false;
      // BMS or ESP32 switch is OFF > Stop Discharging
      else if ((!id(${smartbms_id}_bms_switch_discharging).state) | (!id(${smartbms_id}_switch_discharging).state)) return false;
      // Battery voltage is low > Stop Discharging
      else if (id(${smartbms_id}_total_voltage).state <= id(${smartbms_id}_requested_discharge_voltage).state) return false;
      // Discharging Allowed
      else return true;
          
