# Updated : 2024.04.03
# Version : 2.1.2
# Owner   : MrPablo

# This YAML is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

substitutions:
  # +--------------------------------------+
  # | Use the settings below with caution  |
  # +--------------------------------------+
  # Factor to adjust the aggression of the auto voltage control logic.
  # The higher the setting, the greater the voltage penalty applied to cells exceeding the target voltage (bulk voltage).
  charge_v_factor: "1.5"
  # Factor to adjust the speed of the auto voltage control logic.
  # The higher the setting, the longer the period of time that voltage changes are applied over.
  charge_t_factor: "5"

esphome:
  on_boot:
    then:
      - switch.turn_on: ${smart_bms_id}_switch_auto_cvl

switch:
  - platform: template
    name: ${smart_bms_name} Automatic Charge Voltage
    id: ${smart_bms_id}_switch_auto_cvl
    optimistic: true
    entity_category: config

sensor:
  # +--------------------------------------+
  # | Auto Charge Voltage Control          |
  # +--------------------------------------+
  - platform: template
    name: ${smart_bms_name} Auto Charge Voltage
    id: auto_cvl
    update_interval: ${smart_bms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    internal: true
    lambda: |-
            // Variables
            float charge_v_factor = ${charge_v_factor};
            float cell_bulk_v = (id(${smart_bms_id}_bulk_voltage).state / id(${smart_bms_id}_cell_count).state);
            float target_total_v = 0;
            float excess_v = 0;
            float offset_v = 0;
            float dyn_chg_v = 0;

            // Check feature enabled or if any cells are at / above bulk voltage
            if ((!id(${smart_bms_id}_switch_auto_cvl).state) | (id(${smart_bms_id}_max_cell_voltage).state < cell_bulk_v)){
              id(${smart_bms_id}_auto_cvl) = -1.0;
              return id(${smart_bms_id}_bulk_voltage).state;
            } else {
            // Create array of cell voltages
            float cell_array[] = {
              id(bms1_cell_v_01).state, id(bms1_cell_v_02).state, id(bms1_cell_v_03).state, id(bms1_cell_v_04).state,
              id(bms1_cell_v_05).state, id(bms1_cell_v_06).state, id(bms1_cell_v_07).state, id(bms1_cell_v_08).state,
              id(bms1_cell_v_09).state, id(bms1_cell_v_10).state, id(bms1_cell_v_11).state, id(bms1_cell_v_12).state,
              id(bms1_cell_v_13).state, id(bms1_cell_v_14).state, id(bms1_cell_v_15).state, id(bms1_cell_v_16).state,
              id(bms1_cell_v_17).state, id(bms1_cell_v_18).state, id(bms1_cell_v_19).state, id(bms1_cell_v_20).state,
              id(bms1_cell_v_21).state, id(bms1_cell_v_22).state, id(bms1_cell_v_23).state, id(bms1_cell_v_24).state,
            };
            // Calculate actual total voltage
            for(int i = 0; i < id(${smart_bms_id}_cell_count).state; i++) {
              target_total_v += cell_array[i];
            };
            // Add cell voltage offset to target total voltage if possible
            for(int i = 0; i < id(${smart_bms_id}_cell_count).state; i++) {
              if (cell_array[i] >= cell_bulk_v) {
                excess_v = cell_bulk_v - cell_array[i];
                offset_v = excess_v * charge_v_factor;
                target_total_v += offset_v;
              }
            };
            // Use minimum of dynamic charge voltage or bulk voltage
            dyn_chg_v = min(id(${smart_bms_id}_bulk_voltage).state, target_total_v);
            // Return automatic charge voltage
            return dyn_chg_v;
            }
    filters:    
    - sliding_window_moving_average:
        send_every: 1
        send_first_at: 1
        window_size: ${charge_t_factor}
    - round: 1