# Version : 2024.03.31

# This YAML is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

substitutions:
  # +--------------------------------------+
  # | Use the settings below with caution  |
  # +--------------------------------------+
  # Factor to adjust the aggression of the auto voltage control logic.
  # The higher the setting, the more that requested charge voltage will reduce as cells exceed the target voltage (bulk voltage).
  charge_v_factor: "2.0"

esphome:
  on_boot:
    then:
      - switch.turn_on: ${smart_bms_id}_switch_auto_cvl

switch:
  - platform: template
    name: ${smart_bms_name} Automatic Charge Voltage
    id: ${smart_bms_id}_switch_auto_cvl
    optimistic: true
    entity_category: config

sensor:
  # +--------------------------------------+
  # | Auto Charge Voltage Control          |
  # +--------------------------------------+
  - platform: template
    name: ${smart_bms_name} Auto Charge Voltage
    id: auto_cvl
    update_interval: ${smart_bms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    internal: false
    lambda: !lambda |-

            // Variables
            float charge_v_factor = ${charge_v_factor};
            float cell_bulk_v = (id(bulk_voltage).state / id(cell_count).state);
            float target_total_v = 0;
            float excess_v = 0;
            float offset_v = 0;
            float dyn_chg_v = 0;

            //  Update of the global variable used by smart_bms.yaml (includes if any cells are at / above bulk voltage)
            if ((!id(${smart_bms_id}_switch_auto_cvl).state) | (id(max_cell_voltage).state < cell_bulk_v)) {
              id(${smart_bms_id}_auto_cvl) = -1.0;
              return id(bulk_voltage).state;
            } else {
            // Create array of cell voltages
            float cell_array[] = {
              id(cell_v_01).state, id(cell_v_02).state, id(cell_v_03).state, id(cell_v_04).state,
              id(cell_v_05).state, id(cell_v_06).state, id(cell_v_07).state, id(cell_v_08).state,
              id(cell_v_09).state, id(cell_v_10).state, id(cell_v_11).state, id(cell_v_12).state,
              id(cell_v_13).state, id(cell_v_14).state, id(cell_v_15).state, id(cell_v_16).state,
              id(cell_v_17).state, id(cell_v_18).state, id(cell_v_19).state, id(cell_v_20).state,
              id(cell_v_21).state, id(cell_v_22).state, id(cell_v_23).state, id(cell_v_24).state,
            };
            // Calculate actual total voltage
            for(int i = 0; i < id(cell_count).state; i++) {
              target_total_v += cell_array[i];
            };
            // Add cell voltage offset to target total voltage if possible
            for(int i = 0; i < id(cell_count).state; i++) {
              if (cell_array[i] >= cell_bulk_v) {
                excess_v = cell_array[i] - cell_bulk_v;
                offset_v = (pow(excess_v,2))*(charge_v_factor*-100);
                target_total_v += offset_v;
              }
            };
            // Use minimum of dynamic charge voltage or bulk voltage
            dyn_chg_v = min(id(bulk_voltage).state, target_total_v);
            // Return automatic charge voltage
            return ceil(dyn_chg_v * 10) / 10;
            }
