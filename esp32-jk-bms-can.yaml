# JK-BMS-CAN ( PYLON protocol )

# V1.15.1 Sleeper85 : New CANBUS script with CANBUS Status in HA, stop sending CAN messages if the inverter is not responding (fix WDT reboot issues).
# V1.14.3 Sleeper85 : Improved documentation + Charging Voltage tips for Deye
# V1.14.2 Sleeper85 : Improve 'Charging Voltage' behavior
# V1.14.1 Sleeper85 : Add 'Float charge function'
# V1.13.6 Sleeper85 : Add 'Absorption time' and 'Absorption Offset V.' slider
# V1.13.5 Sleeper85 : Set CAN manufacter to "PYLON" for improve compatibility with Deye and other inverters
# V1.13.4 Sleeper85 : Improve 'Charge Status' behavior + add 'Rebulk Offset V.' slider
# V1.13.3 uksa007   : Improve compatibility with Deye and other inverters
# V1.13.2 uksa007   : Send Max Temperature of T1, T2 to inverter
# V1.13.1 uksa007   : Fix compile issues with new version of ESPhome 2023.4.0, set rebulk offset to 2.5

substitutions:
# +--------------------------------------+
# name that will appear in esphome and homeassistant.
  name: jk-bms-can
# +--------------------------------------+
# Number of Battery modules max 8. Each LX U5.4-L battery is 5.4kWh, select the number closest to your capactiy eg 3.2V * 280Ah * 16 = 14.3kWh
  batt_modules: "3"
# +--------------------------------------+
# | Battery Charge Settings              |
# +--------------------------------------+
# Tips for Deye inverter : Add 0.1v to the settings below because the Deye charging voltage is always 0.1v lower than requested.
# Float V. : 53.7v		(3.35v/cell - Natural voltage of a fully charged cell at rest, I advise you not to go higher.)
# Absorption V : 55.3v		(3.45v/cell - It's not necessary to use a charging voltage higher than 55.2V for a full charge.)
# Absorption Offset V. : 0.15v	(The absorption phase will start at 55.15v (BMS voltage). Warning: the BMS voltage must be correctly calibrated.)
# +--------------------------------------+
# This is max charging amps eg 50A, for Bulk - Constant Current charging(CC), should be at least 10A less than BMS change current protection, 0.5C max 
  charge_a: "100"
# Float Voltage : corresponds to the voltage at which the battery would be maintained at the end of the absorption phase. (53.6v eg 3.35v/cell for 16 cells 48V battery)
  float_v: "53.6"
# Absorption Voltage : corresponds to the Bulk voltage that will be used to charge the battery. (55.2v eg 3.45v/cell for 16 cells 48V battery)
  absorption_v: "55.2"
# Absorption time in minutes to hold charge voltage after charge voltage is reached eg 30
  absorption_time: "30"
# Absorption offset, x Volts below absorption voltage battery will start the absorption timer, eg 55.2-0.05 = 52.15v
  absorption_offset_v: "0.05"
# Rebulk offset, x Volts below absorption voltage battery will request rebulk, eg 55.2-2.5 = 52.7v
  rebulk_offset_v: "2.5"
# +--------------------------------------+
# | Battery Discharge Settings           |
# +--------------------------------------+
# Max discharge amps eg 100, should be at least 10A less than BMS over discharge current protection, 0.5C max
  discharge_a: "150"
# Minimum discharge voltage eg 48v/16 = 3V per cell
  min_discharge_v: "48"
# +--------------------------------------+
# | Battery State of Health (SOH)        |
# +--------------------------------------+
# Maximum charging cycles is used to calculate the battey SOH, LF280K v3 =8000.0, LF280K v2 =6000.0, LF280=3000.0 (decimal is required)
  max_cycles: "6000.0"
# +--------------------------------------+
# | ESP32 CAN/serial port pins           |
# +--------------------------------------+
# GPIO pins your CAN bus transceiver(TJA1050 or TJA1051T) is connected to the ESP, note! TX->TX and RX->RX. 
  can_tx_pin: GPIO23
  can_rx_pin: GPIO22
# GPIO pins your JK-BMS RS485(TTL) is connected to the ESP TX->RX and RX->TX. 
  tx_pin: GPIO17
  rx_pin: GPIO16
# +--------------------------------------+
# | ** Don't make changes below this **  |
# +--------------------------------------+
  external_components_source: github://syssi/esphome-jk-bms@main
  # components
  # github://syssi/esphome-jk-bms@main
  
esphome:
  name: ${name}
  on_boot:
    then:
      - switch.turn_on: switch_charging
      - switch.turn_on: switch_discharging
      - switch.turn_on: switch_chg_float

esp32:
  board: esp32doit-devkit-v1
#  framework:
#    type: esp-idf
#    version: latest

external_components:
  - source: ${external_components_source}
    refresh: 0s

globals:
  - id: can_ack_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: charge_status
    type: std::string
    restore_value: no
    initial_value: '"Disabled"'
  - id: charging_voltage
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: can_status
    type: std::string
    restore_value: no
    initial_value: '"init"'
  - id: can_msg_counter
    type: int
    restore_value: no
    initial_value: '0'

button:
  - platform: restart
    name: "Restart button"
    id: restart_button
    internal: true

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  domain: !secret domain

ota:

logger:
#  level: DEBUG

# Please use the native `api` component instead of the `mqtt` section
# if you use Home Assistant. The native API is more lightweight.
# If you don't use Home Assistant please remove this `api` section and uncomment the `mqtt` component!
api:

# mqtt:
#  broker: !secret mqtt_host
#  username: !secret mqtt_username
#  password: !secret mqtt_password
#  id: mqtt_client

output:
  - platform: gpio
    pin: 2
    id: led
    inverted: true

light:
  - platform: binary
    output: led
    id: led_buitin
    name: "Builtin LED"
    internal: true

uart:
  id: uart_0
  baud_rate: 115200
  rx_buffer_size: 384
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}
#  debug:
#    direction: BOTH

jk_modbus:
  id: modbus0
  uart_id: uart_0

jk_bms:
  id: bms0
  jk_modbus_id: modbus0
#  enable_fake_traffic: true

canbus:
  - platform: esp32_can
    tx_pin: ${can_tx_pin}
    rx_pin: ${can_rx_pin}
    can_id: 4
    bit_rate: 500kbps
    on_frame:
    - can_id: 0x305 # Inverter ACK - SMA/LG/Pylon/Goodwe reply
      then:
        - light.toggle:
            id: led_buitin
        - lambda: |-
            id(can_ack_counter) = 0;					// Reset ACK counter
            id(can_status) = "ON";					// Set CANBUS Status to ON
            id(canbus_status).publish_state(id(can_status));		// Publish text sensor
            ESP_LOGI("main", "received can id: 0x305 ACK");

interval:
  - interval: 60s
    then:
      - lambda: |-
          id(can_ack_counter) = 0;					// Reset ACK counter for test inverter ACK
          
  - interval: 50ms
    then:
      # Start CAN Handling
      - if:
          condition:
            lambda: |-
              
              if (id(can_ack_counter) < 10) {				// Inverter ACK ? => CANBUS ON
                
                id(can_ack_counter)++;					// CANBUS ACK counter ++
                id(can_msg_counter)++;					// CANBUS MSG counter ++
                return true;						// Condition OK
                
              }
              else if (id(can_status) == "OFF") {			// CANBUS already OFF ?
                
              return false;						// Nothing to do
                
              }
              else {
              
                id(can_status) = "OFF";					// Set CANBUS Status to OFF
                id(canbus_status).publish_state(id(can_status));	// Publish text sensor
                ESP_LOGI("main", "No rx can 0x305 reply, Inverter not connected/responding...");
                return false;						// Condition NOK
                
              }

          then:
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 1;
                then:
                  canbus.send: # Warning, Alarms
                    can_id: 0x359 # Protection & Alarm flags
                    data: !lambda |-
                      uint8_t can_mesg[] = {0, 0, 0, 0, 0, 0, 0, 0};
                      uint16_t jk_errormask = id(errors_bitmask).state;
                      int batt_mods = ${batt_modules};
                      // Alarms
                      if ((jk_errormask & 0x04) | (jk_errormask & 0x80) | (jk_errormask & 0x400)) {	// Hight.Voltage.Alarm JK bit 2,7,10 
                         can_mesg[0] = 0x02;								// byte0_bit1 (0x02 = bin 10)
                      }
                      if ((jk_errormask & 0x08) | (jk_errormask & 0x800)) {				// Low.Voltage.Alarm JK bit 3,11 
                         can_mesg[0] = can_mesg[0] | 0x04;						// byte0_bit2 (0x04 = bin 100)
                      }
                      if ((jk_errormask & 0x02) | (jk_errormask & 0x10) | (jk_errormask & 0x100)) {	// Hight.Temp.Alarm JK bit 1,4,8
                         can_mesg[0] = can_mesg[0] | 0x08;						// byte0_bit3 (0x08 = bin 1000)
                      }
                      if (jk_errormask & 0x200) {							// Low.Temp.Alarm JK bit 9
                         can_mesg[0] = can_mesg[0] | 0x10;						// byte0_bit4 (0x10 = bin 10000)
                      }
                      if (jk_errormask & 0x40) {							// Discharge.Over.Current JK bit 6
                         can_mesg[0] = can_mesg[0] | 0x80;						// byte0_bit7 (0x80 = bin 10000000)
                      }
                      if (jk_errormask & 0x20) {							// Charge.Over.Current JK bit 5
                         can_mesg[1] = 0x01;								// byte1_bit0 (0x01 = bin 1)
                      }
                      if ((jk_errormask & 0x1000) | (jk_errormask & 0x2000)) {				// BMS Internal JK bit 12,13
                         can_mesg[1] = can_mesg[1] | 0x08;						// byte1_bit3 (0x08 = bin 1000)
                      }
                      if (jk_errormask & 0x80) {							// Cell Imbalance JK bit 7
                         can_mesg[1] = can_mesg[1] | 0x10;						// byte1_bit4 (0x10 = bin 10000)
                      }
                      /// Warnings
                      can_mesg[2] = 0x00;		// byte2
                      can_mesg[3] = 0x00;		// byte3
                      /// Flags
                      can_mesg[4] = batt_mods;	// byte4 - Module in parallel
                      can_mesg[5] = 0x00;		// byte5
                      can_mesg[6] = 0x00;		// byte6
                      can_mesg[7] = 0x00;		// byte7 - DIP switches 1,3 10000100 0x84
                      
                      ESP_LOGI("main", "send can id: 0x359 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 2;
                then:
                  canbus.send: # BMS instructs inverter: Charge Volts, Charge Amps, Discharge Amps, Min voltage
                    can_id: 0x351 # Battery voltage + current limits
                    data: !lambda |-
                      
                      // +---------------+
                      // | Charge Status |
                      // +---------------+
                                            
                      // Information from JK BMS is not available immediately after boot
                      // Corresponds to the first status after the boot ( Disabled => Wait => Bulk / Absorption / Float )
                      // Disabled : charging disabled if BMS or HA switch is OFF
                      if ((!id(charging_switch).state) | (!id(switch_charging).state)) {
                           id(charge_status) = "Disabled";
                      }
                      // Wait : all charging swith (BMS and HA) are ON but charge status is 'Disabled'
                      else if ((id(charging_switch).state) & (id(switch_charging).state) & (id(charge_status) == "Disabled")) {
                           id(charge_status) = "Wait";
                      }
                      // Bulk Manually : forced battery charging via HA 'Charging manually (top bal)' switch
                      else if (id(switch_chg_bulk).state) {
                           id(charge_status) = "Bulk Manually";
                      }
                      // Wait : after switch OFF 'Charging manually (top bal)' HA switch
                      else if ((!id(switch_chg_bulk).state) & (id(charge_status) == "Bulk Manually")) {
                           id(charge_status) = "Wait";
                      }
                      // Wait : after switch OFF 'Float charge' HA switch
                      else if ((!id(switch_chg_float).state) & (id(charge_status) == "Float")) {
                           id(charge_status) = "Wait";
                      }
                      // Bulk : if Batt. V. <= ( Absorption V. - Rebulk Offset V. )					( Bulk : <= 55.2-2.5 = 52.7V by default )
                      else if (id(total_voltage).state <= (id(bulk_voltage).state - id(rebulk_offset).state)) {
                           id(charge_status) = "Bulk";
                           if (id(absorption_script).is_running()) id(absorption_script).stop();
                      }
                      // Absorption : if Batt. V >= ( Absorption V. - Absorption Offset V. )				( Absorption : >= 55.2-0.05 = 55.15V by default )
                      else if ((id(charge_status) == "Bulk") & (id(total_voltage).state >= (id(bulk_voltage).state - id(absorption_offset).state))) {
                           id(charge_status) = "Absorption";
                           if (!id(absorption_script).is_running()) id(absorption_script).execute();			// 10 % from top start absorption timer
                      }
                      // Float : if Batt. V. > ( Absorption V. - Rebulk Offset V. ) and Float switch is ON		( Float : after Absorption and > 55.2-2.5 = 52.7V by default )
                      else if ((id(switch_chg_float).state) & (id(charge_status) == "Wait")) {
                           id(charge_status) = "Float";
                      }
                      
                      // +------------------+
                      // | Charging Voltage |
                      // +------------------+
                      
                      if ((id(charge_status) == "Bulk") | (id(charge_status) == "Bulk Manually") | (id(charge_status) == "Absorption")) {
                           id(charging_voltage) = id(bulk_voltage).state;
                      }
                      else if (id(charge_status) == "Float") {
                           id(charging_voltage) = id(float_voltage).state;
                      }
                      // Charge OFF : Wait or Disabled
                      else {
                           id(charging_voltage) = ${min_discharge_v};
                           // id(charging_voltage) = (id(bulk_voltage).state - id(rebulk_offset).state)
                      }
                      
                      // +--------------+
                      // | CAN messages |
                      // +--------------+
                      
                      // can_mesg[0] = byte0 = CVL : Charge Limit Voltage
                      // can_mesg[1] = byte1 = CVL : Charge Limit Voltage
                      // can_mesg[2] = byte2 = CCL : Charge Limit Current
                      // can_mesg[3] = byte3 = CCL : Charge Limit Current
                      
                      // can_mesg[4] = byte4 = DCL : Discharge Limit Current
                      // can_mesg[5] = byte5 = DCL : Discharge Limit Current
                      // can_mesg[6] = byte6 = DVL : Discharge Limit Voltage
                      // can_mesg[7] = byte7 = DVL : Discharge Limit Voltage
                      
                      uint8_t can_mesg[7];
                      
                      // Charge Limit Voltage and Charge Limit Current
                      // Charge ON : Bulk, Bulk Manually, Absorption or Float
                      if ((id(charge_status) == "Bulk") | (id(charge_status) == "Bulk Manually") | (id(charge_status) == "Absorption") | (id(charge_status) == "Float")) {
                         can_mesg[0] = uint16_t(id(charging_voltage) * 10) & 0xff;
                         can_mesg[1] = uint16_t(id(charging_voltage) * 10) >> 8 & 0xff;
                         can_mesg[2] = uint16_t(id(charging_current).state * 10) & 0xff;
                         can_mesg[3] = uint16_t(id(charging_current).state * 10) >> 8 & 0xff;
                      // Charge OFF : Wait or Disabled
                      } else {
                         can_mesg[0] = uint16_t(id(charging_voltage) * 10) & 0xff;
                         can_mesg[1] = uint16_t(id(charging_voltage) * 10) >> 8 & 0xff;
                         can_mesg[2] = 0;
                         can_mesg[3] = 0;
                      }
                                            
                      // Discharge Limit Current
                      if ((id(discharging_switch).state) & (id(switch_discharging).state)) {
                        can_mesg[4] = uint16_t(${discharge_a} * 10) & 0xff;
                        can_mesg[5] = uint16_t(${discharge_a} * 10) >> 8 & 0xff;
                      } else {
                         can_mesg[4] = 0x00;
                         can_mesg[5] = 0x00;
                      }
                      
                      // Discharge Limit Voltage
                      can_mesg[6] = uint16_t(${min_discharge_v} * 10) & 0xff;
                      can_mesg[7] = uint16_t(${min_discharge_v} * 10) >> 8 & 0xff;
                      
                      // Publish text sensor
                      id(charging_status).publish_state(id(charge_status));
                      
                      // Logs
                      ESP_LOGI("main", "send can id: 0x351 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      ESP_LOGI("main", "send can id: Charge Status %s", id(charge_status).c_str());
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 3;
                then:
                  canbus.send: # Actual SOC, SOH
                    can_id: 0x355 # State of Health (SOH) / State of Charge (SOC)
                    data: !lambda |-
                      int soh = round(((id(charging_cycles).state/${max_cycles})-1)*-100);
                      uint8_t can_mesg[3];
                      can_mesg[0] = uint16_t(id(capacity_remaining).state) & 0xff;
                      can_mesg[1] = uint16_t(id(capacity_remaining).state) >> 8 & 0xff;
                      can_mesg[2] = soh & 0xff;
                      can_mesg[3] = soh >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x355 hex: %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3]};
                      
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 4;
                then:
                  canbus.send: # Actual Volts, Amps, Temp
                    can_id: 0x356 # Voltage / Current / Temperature (Deye 0x305 ACK)
                    data: !lambda |-
                      uint8_t can_mesg[5];
                      can_mesg[0] = uint16_t(id(total_voltage).state * 100) & 0xff;
                      can_mesg[1] = uint16_t(id(total_voltage).state * 100) >> 8 & 0xff;
                      can_mesg[2] = int16_t(id(current).state * 10) & 0xff;
                      can_mesg[3] = int16_t(id(current).state * 10) >> 8 & 0xff;
                      can_mesg[4] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[5] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x356 hex: %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5]};
                      
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 5;
                then:
                  canbus.send: # Request flag to Enable/Disable: Charge, Discharge
                    can_id: 0x35C   # Battery charge request flags
                    data: !lambda |-
                      uint8_t can_mesg[1];
                      if ((id(charging_switch).state) & (id(switch_charging).state)) {
                         can_mesg[0] = 0x80;
                      } else {
                         can_mesg[0] = 0x00;
                      }
                      if ((id(discharging_switch).state) & (id(switch_discharging).state)) {
                         can_mesg[0] = can_mesg[0] | 0x40;
                      }
                      can_mesg[1] = 0x00;
                      ESP_LOGI("main", "send can id: 0x35C hex: %x %x", can_mesg[0], can_mesg[1]);
                      return {can_mesg[0], can_mesg[1]};
                      
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 6;
                then:
                  canbus.send: # Actual Max Cell Temp, Min Cell Temp, Max Cell V, Min Cell V
                    can_id: 0x70
                    data: !lambda |-
                      int max_cell_voltage_i = id(max_cell_voltage).state * 100.0;
                      int min_cell_voltage_i = id(min_cell_voltage).state * 100.0;
                      uint8_t can_mesg[7];
                      can_mesg[0] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[1] = int16_t(max(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[2] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) & 0xff;
                      can_mesg[3] = int16_t(min(id(temperature_sensor_1).state, id(temperature_sensor_2).state)* 10) >> 8 & 0xff;
                      can_mesg[4] = max_cell_voltage_i & 0xff;
                      can_mesg[5] = max_cell_voltage_i >> 8 & 0xff;
                      can_mesg[6] = min_cell_voltage_i & 0xff;
                      can_mesg[7] = min_cell_voltage_i >> 8 & 0xff;
                      ESP_LOGI("main", "send can id: 0x70 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                      return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                      
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 7;
                then:
                  - canbus.send: # Actual Max Cell Temp ID, Min Cell Temp ID, Max Cell V ID, Min Cell ID
                      can_id: 0x371
                      data: !lambda |-
                        uint8_t can_mesg[7];
                        can_mesg[0] = 0x01;
                        can_mesg[1] = 0x00;
                        can_mesg[2] = 0x02;
                        can_mesg[3] = 0x00;
                        can_mesg[4] = uint16_t(id(max_voltage_cell).state) & 0xff;
                        can_mesg[5] = uint16_t(id(max_voltage_cell).state) >> 8 & 0xff;
                        can_mesg[6] = uint16_t(id(min_voltage_cell).state) & 0xff;
                        can_mesg[7] = uint16_t(id(min_voltage_cell).state) >> 8 & 0xff;
                        ESP_LOGI("main", "send can id: 0x371 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
                        return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
                        
            - if:
                condition:
                  lambda: |-
                    return id(can_msg_counter) == 8;
                then:
                  - canbus.send:
                      can_id: 0x35E # Manufacturer name ("GOODWE")
                      data: [0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20]
                      # PYLON  : 0x50, 0x59, 0x4C, 0x4F, 0x4E, 0x20, 0x20, 0x20	( recognized by Deye, display PYLON name and SOH )
                      # GOODWE : 0x47, 0x4F, 0x4F, 0x44, 0x57, 0x45, 0x20, 0x20
                      # GoodWe : 0x47, 0x6F, 0x6F, 0x64, 0x57, 0x65, 0x20, 0x20
                      # Energy : 0x45, 0x6E, 0x65, 0x72, 0x67, 0x79, 0x20, 0x20	( SEPLOS V1.0 )

                  - lambda: |- # Reset counter
                      ESP_LOGI("main", "send can id: 0x35E ASCII : PYLON");
                      id(can_msg_counter) = 0;
                      
binary_sensor:
  - platform: jk_bms
    balancing:
      name: "${name} balancing"
    balancing_switch:
      name: "${name} balancing switch"
    charging:
      name: "${name} charging"
    charging_switch:
      id: charging_switch
      name: "${name} charging switch"
    discharging:
      name: "${name} discharging"
    discharging_switch:
      id: discharging_switch
      name: "${name} discharging switch"
    dedicated_charger_switch:
      name: "${name} dedicated charger switch"

sensor:
  - platform: jk_bms
    min_cell_voltage:
      id: min_cell_voltage
      name: "${name} min cell voltage"
    max_cell_voltage:
      id: max_cell_voltage
      name: "${name} max cell voltage"
    min_voltage_cell:
      id: min_voltage_cell
      name: "${name} min voltage cell"
    max_voltage_cell:
      id: max_voltage_cell
      name: "${name} max voltage cell"
    delta_cell_voltage:
      name: "${name} delta cell voltage"
    average_cell_voltage:
      name: "${name} average cell voltage"
    cell_voltage_1:
      name: "${name} cell voltage 1"
    cell_voltage_2:
      name: "${name} cell voltage 2"
    cell_voltage_3:
      name: "${name} cell voltage 3"
    cell_voltage_4:
      name: "${name} cell voltage 4"
    cell_voltage_5:
      name: "${name} cell voltage 5"
    cell_voltage_6:
      name: "${name} cell voltage 6"
    cell_voltage_7:
      name: "${name} cell voltage 7"
    cell_voltage_8:
      name: "${name} cell voltage 8"
    cell_voltage_9:
      name: "${name} cell voltage 9"
    cell_voltage_10:
      name: "${name} cell voltage 10"
    cell_voltage_11:
      name: "${name} cell voltage 11"
    cell_voltage_12:
      name: "${name} cell voltage 12"
    cell_voltage_13:
      name: "${name} cell voltage 13"
    cell_voltage_14:
      name: "${name} cell voltage 14"
    cell_voltage_15:
      name: "${name} cell voltage 15"
    cell_voltage_16:
      name: "${name} cell voltage 16"
#    cell_voltage_17:
#      name: "${name} cell voltage 17"
#    cell_voltage_18:
#      name: "${name} cell voltage 18"
#    cell_voltage_19:
#      name: "${name} cell voltage 19"
#    cell_voltage_20:
#      name: "${name} cell voltage 20"
#    cell_voltage_21:
#      name: "${name} cell voltage 21"
#    cell_voltage_22:
#      name: "${name} cell voltage 22"
#    cell_voltage_23:
#      name: "${name} cell voltage 23"
#    cell_voltage_24:
#      name: "${name} cell voltage 24"
    power_tube_temperature:
      id: power_tube_temperature
      name: "${name} power tube temperature"
    temperature_sensor_1:
      id: temperature_sensor_1
      name: "${name} temperature sensor 1"
    temperature_sensor_2:
      id: temperature_sensor_2
      name: "${name} temperature sensor 2"
    total_voltage:
      id: total_voltage
      name: "${name} total voltage"
    current:
      id: current
      name: "${name} current"
    power:
      name: "${name} power"
    charging_power:
      name: "${name} charging power"
    discharging_power:
      name: "${name} discharging power"
    capacity_remaining:
      id: capacity_remaining
      name: "${name} capacity remaining"
    capacity_remaining_derived:
      name: "${name} capacity remaining derived"
    temperature_sensors:
      name: "${name} temperature sensors"
    charging_cycles:
      name: "${name} charging cycles"
      id: charging_cycles
    total_charging_cycle_capacity:
      name: "${name} total charging cycle capacity"
    battery_strings:
      name: "${name} battery strings"
    errors_bitmask:
      id: errors_bitmask
      name: "${name} errors bitmask"
    operation_mode_bitmask:
      name: "${name} operation mode bitmask"
    total_voltage_overvoltage_protection:
      name: "${name} total voltage overvoltage protection"
    total_voltage_undervoltage_protection:
      id: total_voltage_undervoltage_protection
      name: "${name} total voltage undervoltage protection"
    cell_voltage_overvoltage_protection:
      name: "${name} cell voltage overvoltage protection"
    cell_voltage_overvoltage_recovery:
      name: "${name} cell voltage overvoltage recovery"
    cell_voltage_overvoltage_delay:
      name: "${name} cell voltage overvoltage delay"
    cell_voltage_undervoltage_protection:
      name: "${name} cell voltage undervoltage protection"
    cell_voltage_undervoltage_recovery:
      name: "${name} cell voltage undervoltage recovery"
    cell_voltage_undervoltage_delay:
      name: "${name} cell voltage undervoltage delay"
    cell_pressure_difference_protection:
      name: "${name} cell pressure difference protection"
    discharging_overcurrent_protection:
      id: discharging_overcurrent_protection
      name: "${name} discharging overcurrent protection"
    discharging_overcurrent_delay:
      name: "${name} discharging overcurrent delay"
    charging_overcurrent_protection:
      id: charging_overcurrent_protection
      name: "${name} charging overcurrent protection"
    charging_overcurrent_delay:
      name: "${name} charging overcurrent delay"
    balance_starting_voltage:
      name: "${name} balance starting voltage"
    balance_opening_pressure_difference:
      name: "${name} balance opening pressure difference"
    power_tube_temperature_protection:
      name: "${name} power tube temperature protection"
    power_tube_temperature_recovery:
      name: "${name} power tube temperature recovery"
    temperature_sensor_temperature_protection:
      name: "${name} temperature sensor temperature protection"
    temperature_sensor_temperature_recovery:
      name: "${name} temperature sensor temperature recovery"
    temperature_sensor_temperature_difference_protection:
      name: "${name} temperature sensor temperature difference protection"
    charging_high_temperature_protection:
      name: "${name} charging high temperature protection"
    discharging_high_temperature_protection:
      name: "${name} discharging high temperature protection"
    charging_low_temperature_protection:
      name: "${name} charging low temperature protection"
    charging_low_temperature_recovery:
      name: "${name} charging low temperature recovery"
    discharging_low_temperature_protection:
      name: "${name} discharging low temperature protection"
    discharging_low_temperature_recovery:
      name: "${name} discharging low temperature recovery"
    total_battery_capacity_setting:
      name: "${name} total battery capacity setting"
    current_calibration:
      name: "${name} current calibration"
    device_address:
      name: "${name} device address"
    sleep_wait_time:
      name: "${name} sleep wait time"
    alarm_low_volume:
      name: "${name} alarm low volume"
    manufacturing_date:
      name: "${name} manufacturing date"
    total_runtime:
      name: "${name} total runtime"
#    start_current_calibration:
#      name: "${name} start current calibration"
    actual_battery_capacity:
      name: "${name} actual battery capacity"
#    protocol_version:
#      name: "${name} protocol version"

# Uptime sensor
  - platform: uptime
    name: ${name} Uptime Sensor
    id: uptime_sensor
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + "d " : "") +
                (hours ? to_string(hours) + "h " : "") +
                (minutes ? to_string(minutes) + "m " : "") +
                (to_string(seconds) + "s")
              ).c_str();

text_sensor:
  - platform: jk_bms
    errors:
      name: "${name} errors"
    operation_mode:
      name: "${name} operation mode"
    battery_type:
      name: "${name} battery type"
#    password:
#      name: "${name} password"
    device_type:
      name: "${name} device type"
    software_version:
      name: "${name} software version"
    manufacturer:
      name: "${name} manufacturer"
    total_runtime_formatted:
      name: "${name} total runtime formatted"
# Template text sensors
  - platform: template
    name: ${name} Uptime Human Readable
    id: uptime_human
    icon: mdi:clock-start
  - platform: template
    name: "${name} Charging Status"
    id: charging_status
  - platform: template
    name: "${name} CANBUS Status"
    id: canbus_status

# Slider
number:
  - platform: template
    name: "${name} Bulk voltage"
    id: "bulk_voltage"
    step: 0.1
    min_value: 52.8
    max_value: 57.6
    mode: slider
    initial_value: "${absorption_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
  - platform: template
    name: "${name} Float voltage"
    id: "float_voltage"
    step: 0.1
    min_value: 52.8
    max_value: 57.6
    mode: slider
    initial_value: "${float_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
  - platform: template
    name: "${name} Charging current max"
    id: "charging_current"
    step: 1
    min_value: 0
    max_value: 150
    mode: slider
    initial_value: "${charge_a}"
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
  - platform: template
    name: "${name} Rebulk Offset V."
    id: "rebulk_offset"
    step: 0.1
    min_value: 0
    max_value: 5
    mode: slider
    initial_value: "${rebulk_offset_v}"
    unit_of_measurement: V
    icon: mdi:sine-wave
    optimistic: true
  - platform: template
    name: "${name} Absorption time"
    id: "absorption_time"
    step: 1
    min_value: 0
    max_value: 180
    mode: slider
    initial_value: "${absorption_time}"
    unit_of_measurement: min
    icon: mdi:clock-start
    optimistic: true
  - platform: template
    name: "${name} Absorption Offset V."
    id: "absorption_offset"
    step: 0.05
    min_value: 0
    max_value: 1
    mode: slider
    initial_value: "${absorption_offset_v}"
    unit_of_measurement: V
    icon: mdi:sine-wave
    optimistic: true

script:
  - id: absorption_script
    then:
      - lambda: id(charge_status) = "Absorption";
      # delay value in ms
      - delay: !lambda "return id(absorption_time).state * 60 * 1000;"
      - lambda: id(charge_status) = "Wait";

switch:
  - platform: template
    name: ${name} Charging enabled
    id: switch_charging
    optimistic: true
  - platform: template
    name: ${name} Discharge enabled
    id: switch_discharging
    optimistic: true
  - platform: template
    name: ${name} Charging manually (top bal)
    id: switch_chg_bulk
    optimistic: true
  - platform: template
    name: ${name} Float charge
    id: switch_chg_float
    optimistic: true
